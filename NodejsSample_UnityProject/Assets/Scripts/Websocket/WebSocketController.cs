using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Inworld;
using UnityEngine;
using UnityEngine.Networking;

public class WebSocketController : MonoBehaviour
{
    const int k_sampleRate = 16000;

    [SerializeField]
    float m_sendInterval = 0.1f; // 100ms

    WebSocket m_webSocket;
    AudioClip m_microphoneClip;
    bool m_isRecording = false;
    bool m_isCharacterSpeaking = false;
    AudioSource m_audioSource;
    List<List<float>> m_audioQueue = new List<List<float>>();
    
    // Events
    public event Action<string, string, string> OnTextReceived;
    public event Action<string> OnErrorReceived;
    public event Action OnInteractionEnd;
    public event Action OnConnected;
    public event Action OnDisconnected;
    public event Action OnRecordingStarted;
    public event Action OnRecordingStopped;
    public event Action<bool> OnAudioPlayingChanged;

    void Awake()
    {
        m_audioSource = GetComponent<AudioSource>();
    }

    void Update()
    {
        if(m_audioSource.clip == null || m_audioSource.isPlaying == false)
        {
            if(TTSQueue.Count > 0)
            {
                string base64Audio = TTSQueue.Dequeue();
                try
                {
                    byte[] audioBytes = System.Convert.FromBase64String(base64Audio);
                    m_audioSource.clip = WavUtility.ToAudioClip(audioBytes);
                    m_audioSource.Play();
                    if (!m_isCharacterSpeaking)
                    {
                        OnAudioPlayingChanged?.Invoke(true);
                        m_isCharacterSpeaking = true;
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogError($"Cannot Play Audio: {ex.Message}");
                }
            }
            else if (m_isCharacterSpeaking)
            {
                m_isCharacterSpeaking = false;
                OnAudioPlayingChanged?.Invoke(false);
            }
        }   
    }

    [Serializable]
    class CreateSessionResp 
    { 
        public string sessionKey; 
        public string wsToken; 
    }

    public IEnumerator InitializeConnection(string httpURL, string wsURL)
    {
        // Create session via UnityWebRequest using Authorization generated by your InworldAuth
        string sessionKey = null;
        string wsToken = null;
        string authority = new Uri(httpURL).Authority; // host[:port]
        string apiKey = AppManager_WS.Instance.GetAPIKey();
        string apiSecret = AppManager_WS.Instance.GetAPISecret();
        if (string.IsNullOrEmpty(apiKey) || string.IsNullOrEmpty(apiSecret))
        {
            Debug.LogError("Missing APIKey/APISecret on AppManager_WS.");
            yield break;
        }
        string authHeader = InworldAuth.GetHeader(authority, apiKey, apiSecret);

        UnityWebRequest request = UnityWebRequest.PostWwwForm($"{httpURL}/create-session", "");
        request.SetRequestHeader("Authorization", authHeader);
        yield return request.SendWebRequest();
        if (request.result != UnityWebRequest.Result.Success)
        {
            Debug.LogError("Session creation failed: " + request.error + "\n" + request.downloadHandler.text);
            yield break;
        }
        string json = request.downloadHandler.text;
        try
        {
            var resp = JsonUtility.FromJson<CreateSessionResp>(json);
            sessionKey = resp.sessionKey;
            wsToken = resp.wsToken;
        }
        catch (Exception ex) 
        { 
            Debug.LogError("Parse session JSON failed: " + ex.Message + "\n" + json); 
        }

        if (string.IsNullOrEmpty(sessionKey) || string.IsNullOrEmpty(wsToken))
        { 
            Debug.LogError("Missing sessionKey or wsToken"); yield break; 
        }
        Debug.Log("Session key: " + sessionKey);

        // Use short-lived wsToken issued by /create-session for WS auth (no full Authorization in URL)
        Uri httpUri = new Uri(httpURL);
        string wsScheme = httpUri.Scheme == "https" ? "wss" : "ws";
        string hostPort = httpUri.IsDefaultPort ? httpUri.Host : $"{httpUri.Host}:{httpUri.Port}";
        string url = $"{wsScheme}://{hostPort}/ws?key={sessionKey}&wsToken={UnityWebRequest.EscapeURL(wsToken)}";
        Debug.Log($"Connecting to WebSocket: {url}");
        m_webSocket = WebSocketManager.GetWebSocket(url);
        if (m_webSocket == null)
        {
            m_webSocket = new WebSocket(url);
        }

        m_webSocket.OnOpen += (sender, e) =>
        {
            Debug.Log("Websocket Connected");
            OnConnected?.Invoke();
        };

        m_webSocket.OnMessage += (sender, e) =>
        {
            // Debug.Log($"Websocket Message Received {e.Data}");
            HandleServerMessage(e.Data);
        };

        m_webSocket.OnError += (sender, e) =>
        {
            Debug.LogError($"WebSocket Error: {e.Message}");
            OnErrorReceived?.Invoke($"WebSocket Error: {e.Message}");
        };

        m_webSocket.OnClose += (sender, e) =>
        {
            Debug.Log("WebSocket Close");
            OnDisconnected?.Invoke();
        };
        
        m_webSocket.ConnectAsync();
    }

    // Removed HttpClient-based session creation; using UnityWebRequest above
    void HandleServerMessage(string jsonMessage)
    {
        try
        {
            ServerMessage message = JsonUtility.FromJson<ServerMessage>(jsonMessage);

            switch (message.type)
            {
                case "TEXT":
                    if (message.text != null && message.text.final)
                    {
                        Debug.Log($"Get Text: {message.text.text}");
                        OnTextReceived?.Invoke(message.text.text, message.routing.source.name, message.packetId.interactionId);
                    }
                    break;

                case "AUDIO":
                    if (!string.IsNullOrEmpty(message.audio.chunk))
                    {
                        Debug.Log($"Audio packet received");
                        PlayAudioFromBase64(message.audio.chunk);
                    }
                    break;

                case "ERROR":
                    Debug.LogError($"Server Error: {message.error}");
                    OnErrorReceived?.Invoke(message.error);
                    break;

                case "INTERACTION_END":
                    OnInteractionEnd?.Invoke();
                    break;
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Sever Exception: {ex.Message}");
        }
    }

    public void SendImageWithPrompt(string text, byte[] imageByte, string voiceId)
    {
        if (m_webSocket != null && m_webSocket.ReadyState == WebSocketState.Open)
        {
            string imageUrl = $"data:image/jpeg;base64,{Convert.ToBase64String(imageByte)}";
            ClientLLMInput message = new ClientLLMInput
            {
                type = "imageChat",
                text = text,
                image = imageUrl,
                voiceId = voiceId
            };

            string jsonMessage = JsonUtility.ToJson(message);
            m_webSocket.SendAsync(jsonMessage);
            Debug.Log($"Sending Image...");
        }
        else
        {
            Debug.LogWarning("WebSocket not connected");
        }
    }

    // Button event: On Recording button pressed
    public void StartRecording()
    {
        if (m_isRecording) return;

        string microphoneName = Microphone.devices.Length > 0 ? Microphone.devices[0] : null;
        if (microphoneName == null)
        {
            Debug.LogError("No Microphone");
            return;
        }

        m_microphoneClip = Microphone.Start(microphoneName, true, 10, k_sampleRate);
        m_isRecording = true;

        OnRecordingStarted?.Invoke();
        StartCoroutine(SendAudioData());
        //Debug.Log("Start Recording");
    }

    public void StopRecording()
    {
        if (!m_isRecording)
        {
            return;
        }
            
        Microphone.End(null);
        m_isRecording = false;

        if (m_webSocket != null && m_webSocket.ReadyState == WebSocketState.Open)
        {
            ClientMessage endMessage = new ClientMessage
            {
                type = "audioSessionEnd"
            };
            m_webSocket.SendAsync(JsonUtility.ToJson(endMessage));
        }
        OnRecordingStopped?.Invoke();
        //Debug.Log("Stop Recording");
    }

    IEnumerator SendAudioData()
    {
        int lastSample = 0;

        while (m_isRecording)
        {
            // Debug.Log($"In recording... {Time.realtimeSinceStartup}");
            int currentSample = Microphone.GetPosition(null);
            if (currentSample > lastSample)
            {
                int sampleCount = currentSample - lastSample;
                float[] samples = new float[sampleCount];
                m_microphoneClip.GetData(samples, lastSample);
                m_audioQueue.Add(samples.ToList());
                 SendAudioChunk();
                lastSample = currentSample;
            }

            yield return new WaitForSeconds(m_sendInterval);
        }
    }

    void SendAudioChunk()
    {
        if (m_webSocket != null && m_webSocket.ReadyState == WebSocketState.Open)
        {
            ClientAudioMessage message = new ClientAudioMessage
            {
                type = "audio",
                audio = m_audioQueue
            };
            StringBuilder json = new StringBuilder();
            json.Append("{\"type\":\"audio\",\"audio\":[");
            for (int i = 0; i < m_audioQueue.Count; i++)
            {
                if (i > 0) json.Append(",");
                json.Append("[");

                List<float> chunk = m_audioQueue[i];
                for (int j = 0; j < chunk.Count; j++)
                {
                    if (j > 0) json.Append(",");
                    json.Append(chunk[j].ToString("F6", System.Globalization.CultureInfo.InvariantCulture));
                }
                json.Append("]");
            }

            json.Append("]}");

            // Debug.Log($"Sending Audio....{message.audio.Count} {json}");
            m_webSocket.SendAsync(json.ToString());
            m_audioQueue.Clear();
        }
    }

    Queue<string> TTSQueue = new Queue<string>();

    void PlayAudioFromBase64(string base64Audio)
    {
        TTSQueue.Enqueue(base64Audio);
    }

    public void Disconnect()
    {
        if (m_isRecording)
        {
            StopRecording();
        }

        if (m_webSocket != null)
        {
            m_webSocket.CloseAsync();
            m_webSocket = null;
        }
    }

    void OnDestroy()
    {
        Disconnect();
    }
}
